// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"errors"
	"fmt"
	"github.com/jamelt/openai-api/internal/utils"
)

type ModifyAssistantRequestToolsType string

const (
	ModifyAssistantRequestToolsTypeAssistantToolsCode       ModifyAssistantRequestToolsType = "AssistantToolsCode"
	ModifyAssistantRequestToolsTypeAssistantToolsFileSearch ModifyAssistantRequestToolsType = "AssistantToolsFileSearch"
	ModifyAssistantRequestToolsTypeAssistantToolsFunction   ModifyAssistantRequestToolsType = "AssistantToolsFunction"
)

type ModifyAssistantRequestTools struct {
	AssistantToolsCode       *AssistantToolsCode
	AssistantToolsFileSearch *AssistantToolsFileSearch
	AssistantToolsFunction   *AssistantToolsFunction

	Type ModifyAssistantRequestToolsType
}

func CreateModifyAssistantRequestToolsAssistantToolsCode(assistantToolsCode AssistantToolsCode) ModifyAssistantRequestTools {
	typ := ModifyAssistantRequestToolsTypeAssistantToolsCode

	return ModifyAssistantRequestTools{
		AssistantToolsCode: &assistantToolsCode,
		Type:               typ,
	}
}

func CreateModifyAssistantRequestToolsAssistantToolsFileSearch(assistantToolsFileSearch AssistantToolsFileSearch) ModifyAssistantRequestTools {
	typ := ModifyAssistantRequestToolsTypeAssistantToolsFileSearch

	return ModifyAssistantRequestTools{
		AssistantToolsFileSearch: &assistantToolsFileSearch,
		Type:                     typ,
	}
}

func CreateModifyAssistantRequestToolsAssistantToolsFunction(assistantToolsFunction AssistantToolsFunction) ModifyAssistantRequestTools {
	typ := ModifyAssistantRequestToolsTypeAssistantToolsFunction

	return ModifyAssistantRequestTools{
		AssistantToolsFunction: &assistantToolsFunction,
		Type:                   typ,
	}
}

func (u *ModifyAssistantRequestTools) UnmarshalJSON(data []byte) error {

	var assistantToolsCode AssistantToolsCode = AssistantToolsCode{}
	if err := utils.UnmarshalJSON(data, &assistantToolsCode, "", true, true); err == nil {
		u.AssistantToolsCode = &assistantToolsCode
		u.Type = ModifyAssistantRequestToolsTypeAssistantToolsCode
		return nil
	}

	var assistantToolsFileSearch AssistantToolsFileSearch = AssistantToolsFileSearch{}
	if err := utils.UnmarshalJSON(data, &assistantToolsFileSearch, "", true, true); err == nil {
		u.AssistantToolsFileSearch = &assistantToolsFileSearch
		u.Type = ModifyAssistantRequestToolsTypeAssistantToolsFileSearch
		return nil
	}

	var assistantToolsFunction AssistantToolsFunction = AssistantToolsFunction{}
	if err := utils.UnmarshalJSON(data, &assistantToolsFunction, "", true, true); err == nil {
		u.AssistantToolsFunction = &assistantToolsFunction
		u.Type = ModifyAssistantRequestToolsTypeAssistantToolsFunction
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ModifyAssistantRequestTools", string(data))
}

func (u ModifyAssistantRequestTools) MarshalJSON() ([]byte, error) {
	if u.AssistantToolsCode != nil {
		return utils.MarshalJSON(u.AssistantToolsCode, "", true)
	}

	if u.AssistantToolsFileSearch != nil {
		return utils.MarshalJSON(u.AssistantToolsFileSearch, "", true)
	}

	if u.AssistantToolsFunction != nil {
		return utils.MarshalJSON(u.AssistantToolsFunction, "", true)
	}

	return nil, errors.New("could not marshal union type ModifyAssistantRequestTools: all fields are null")
}

type ModifyAssistantRequestCodeInterpreter struct {
	// Overrides the list of [file](/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.
	//
	FileIds []string `json:"file_ids,omitempty"`
}

func (o *ModifyAssistantRequestCodeInterpreter) GetFileIds() []string {
	if o == nil {
		return nil
	}
	return o.FileIds
}

type ModifyAssistantRequestFileSearch struct {
	// Overrides the [vector store](/docs/api-reference/vector-stores/object) attached to this assistant. There can be a maximum of 1 vector store attached to the assistant.
	//
	VectorStoreIds []string `json:"vector_store_ids,omitempty"`
}

func (o *ModifyAssistantRequestFileSearch) GetVectorStoreIds() []string {
	if o == nil {
		return nil
	}
	return o.VectorStoreIds
}

// ModifyAssistantRequestToolResources - A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.
type ModifyAssistantRequestToolResources struct {
	CodeInterpreter *ModifyAssistantRequestCodeInterpreter `json:"code_interpreter,omitempty"`
	FileSearch      *ModifyAssistantRequestFileSearch      `json:"file_search,omitempty"`
}

func (o *ModifyAssistantRequestToolResources) GetCodeInterpreter() *ModifyAssistantRequestCodeInterpreter {
	if o == nil {
		return nil
	}
	return o.CodeInterpreter
}

func (o *ModifyAssistantRequestToolResources) GetFileSearch() *ModifyAssistantRequestFileSearch {
	if o == nil {
		return nil
	}
	return o.FileSearch
}

// ModifyAssistantRequestMetadata - Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
type ModifyAssistantRequestMetadata struct {
}

type ModifyAssistantRequest struct {
	// ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them.
	//
	Model *string `json:"model,omitempty"`
	// The name of the assistant. The maximum length is 256 characters.
	//
	Name *string `json:"name,omitempty"`
	// The description of the assistant. The maximum length is 512 characters.
	//
	Description *string `json:"description,omitempty"`
	// The system instructions that the assistant uses. The maximum length is 256,000 characters.
	//
	Instructions *string `json:"instructions,omitempty"`
	// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`.
	//
	Tools []ModifyAssistantRequestTools `json:"tools,omitempty"`
	// A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.
	//
	ToolResources *ModifyAssistantRequestToolResources `json:"tool_resources,omitempty"`
	// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
	//
	Metadata *ModifyAssistantRequestMetadata `json:"metadata,omitempty"`
	// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
	//
	Temperature *float64 `default:"1" json:"temperature"`
	// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
	//
	// We generally recommend altering this or temperature but not both.
	//
	TopP *float64 `default:"1" json:"top_p"`
	// Specifies the format that the model must output. Compatible with [GPT-4o](/docs/models#gpt-4o), [GPT-4 Turbo](/docs/models#gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.
	//
	// Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema. Learn more in the [Structured Outputs guide](/docs/guides/structured-outputs).
	//
	// Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates is valid JSON.
	//
	// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
	//
	ResponseFormat *AssistantsAPIResponseFormatOption `json:"response_format,omitempty"`
}

func (m ModifyAssistantRequest) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(m, "", false)
}

func (m *ModifyAssistantRequest) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &m, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *ModifyAssistantRequest) GetModel() *string {
	if o == nil {
		return nil
	}
	return o.Model
}

func (o *ModifyAssistantRequest) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *ModifyAssistantRequest) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *ModifyAssistantRequest) GetInstructions() *string {
	if o == nil {
		return nil
	}
	return o.Instructions
}

func (o *ModifyAssistantRequest) GetTools() []ModifyAssistantRequestTools {
	if o == nil {
		return nil
	}
	return o.Tools
}

func (o *ModifyAssistantRequest) GetToolResources() *ModifyAssistantRequestToolResources {
	if o == nil {
		return nil
	}
	return o.ToolResources
}

func (o *ModifyAssistantRequest) GetMetadata() *ModifyAssistantRequestMetadata {
	if o == nil {
		return nil
	}
	return o.Metadata
}

func (o *ModifyAssistantRequest) GetTemperature() *float64 {
	if o == nil {
		return nil
	}
	return o.Temperature
}

func (o *ModifyAssistantRequest) GetTopP() *float64 {
	if o == nil {
		return nil
	}
	return o.TopP
}

func (o *ModifyAssistantRequest) GetResponseFormat() *AssistantsAPIResponseFormatOption {
	if o == nil {
		return nil
	}
	return o.ResponseFormat
}
