// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/jamelt/openai-api/internal/utils"
)

// Object - The object type, which is always `assistant`.
type Object string

const (
	ObjectAssistant Object = "assistant"
)

func (e Object) ToPointer() *Object {
	return &e
}
func (e *Object) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "assistant":
		*e = Object(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Object: %v", v)
	}
}

type ToolsType string

const (
	ToolsTypeAssistantToolsCode       ToolsType = "AssistantToolsCode"
	ToolsTypeAssistantToolsFileSearch ToolsType = "AssistantToolsFileSearch"
	ToolsTypeAssistantToolsFunction   ToolsType = "AssistantToolsFunction"
)

type Tools struct {
	AssistantToolsCode       *AssistantToolsCode
	AssistantToolsFileSearch *AssistantToolsFileSearch
	AssistantToolsFunction   *AssistantToolsFunction

	Type ToolsType
}

func CreateToolsAssistantToolsCode(assistantToolsCode AssistantToolsCode) Tools {
	typ := ToolsTypeAssistantToolsCode

	return Tools{
		AssistantToolsCode: &assistantToolsCode,
		Type:               typ,
	}
}

func CreateToolsAssistantToolsFileSearch(assistantToolsFileSearch AssistantToolsFileSearch) Tools {
	typ := ToolsTypeAssistantToolsFileSearch

	return Tools{
		AssistantToolsFileSearch: &assistantToolsFileSearch,
		Type:                     typ,
	}
}

func CreateToolsAssistantToolsFunction(assistantToolsFunction AssistantToolsFunction) Tools {
	typ := ToolsTypeAssistantToolsFunction

	return Tools{
		AssistantToolsFunction: &assistantToolsFunction,
		Type:                   typ,
	}
}

func (u *Tools) UnmarshalJSON(data []byte) error {

	var assistantToolsCode AssistantToolsCode = AssistantToolsCode{}
	if err := utils.UnmarshalJSON(data, &assistantToolsCode, "", true, true); err == nil {
		u.AssistantToolsCode = &assistantToolsCode
		u.Type = ToolsTypeAssistantToolsCode
		return nil
	}

	var assistantToolsFileSearch AssistantToolsFileSearch = AssistantToolsFileSearch{}
	if err := utils.UnmarshalJSON(data, &assistantToolsFileSearch, "", true, true); err == nil {
		u.AssistantToolsFileSearch = &assistantToolsFileSearch
		u.Type = ToolsTypeAssistantToolsFileSearch
		return nil
	}

	var assistantToolsFunction AssistantToolsFunction = AssistantToolsFunction{}
	if err := utils.UnmarshalJSON(data, &assistantToolsFunction, "", true, true); err == nil {
		u.AssistantToolsFunction = &assistantToolsFunction
		u.Type = ToolsTypeAssistantToolsFunction
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Tools", string(data))
}

func (u Tools) MarshalJSON() ([]byte, error) {
	if u.AssistantToolsCode != nil {
		return utils.MarshalJSON(u.AssistantToolsCode, "", true)
	}

	if u.AssistantToolsFileSearch != nil {
		return utils.MarshalJSON(u.AssistantToolsFileSearch, "", true)
	}

	if u.AssistantToolsFunction != nil {
		return utils.MarshalJSON(u.AssistantToolsFunction, "", true)
	}

	return nil, errors.New("could not marshal union type Tools: all fields are null")
}

type AssistantObjectCodeInterpreter struct {
	// A list of [file](/docs/api-reference/files) IDs made available to the `code_interpreter`` tool. There can be a maximum of 20 files associated with the tool.
	//
	FileIds []string `json:"file_ids,omitempty"`
}

func (o *AssistantObjectCodeInterpreter) GetFileIds() []string {
	if o == nil {
		return nil
	}
	return o.FileIds
}

type AssistantObjectFileSearch struct {
	// The ID of the [vector store](/docs/api-reference/vector-stores/object) attached to this assistant. There can be a maximum of 1 vector store attached to the assistant.
	//
	VectorStoreIds []string `json:"vector_store_ids,omitempty"`
}

func (o *AssistantObjectFileSearch) GetVectorStoreIds() []string {
	if o == nil {
		return nil
	}
	return o.VectorStoreIds
}

// ToolResources - A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.
type ToolResources struct {
	CodeInterpreter *AssistantObjectCodeInterpreter `json:"code_interpreter,omitempty"`
	FileSearch      *AssistantObjectFileSearch      `json:"file_search,omitempty"`
}

func (o *ToolResources) GetCodeInterpreter() *AssistantObjectCodeInterpreter {
	if o == nil {
		return nil
	}
	return o.CodeInterpreter
}

func (o *ToolResources) GetFileSearch() *AssistantObjectFileSearch {
	if o == nil {
		return nil
	}
	return o.FileSearch
}

// Metadata - Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
type Metadata struct {
}

// AssistantObject - Represents an `assistant` that can call the model and use tools.
type AssistantObject struct {
	// The identifier, which can be referenced in API endpoints.
	ID string `json:"id"`
	// The object type, which is always `assistant`.
	Object Object `json:"object"`
	// The Unix timestamp (in seconds) for when the assistant was created.
	CreatedAt int64 `json:"created_at"`
	// The name of the assistant. The maximum length is 256 characters.
	//
	Name *string `json:"name"`
	// The description of the assistant. The maximum length is 512 characters.
	//
	Description *string `json:"description"`
	// ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them.
	//
	Model string `json:"model"`
	// The system instructions that the assistant uses. The maximum length is 256,000 characters.
	//
	Instructions *string `json:"instructions"`
	// A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`.
	//
	Tools []Tools `json:"tools"`
	// A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.
	//
	ToolResources *ToolResources `json:"tool_resources,omitempty"`
	// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
	//
	Metadata *Metadata `json:"metadata"`
	// What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
	//
	Temperature *float64 `default:"1" json:"temperature"`
	// An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
	//
	// We generally recommend altering this or temperature but not both.
	//
	TopP *float64 `default:"1" json:"top_p"`
	// Specifies the format that the model must output. Compatible with [GPT-4o](/docs/models#gpt-4o), [GPT-4 Turbo](/docs/models#gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.
	//
	// Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema. Learn more in the [Structured Outputs guide](/docs/guides/structured-outputs).
	//
	// Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates is valid JSON.
	//
	// **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if `finish_reason="length"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.
	//
	ResponseFormat *AssistantsAPIResponseFormatOption `json:"response_format,omitempty"`
}

func (a AssistantObject) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AssistantObject) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *AssistantObject) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *AssistantObject) GetObject() Object {
	if o == nil {
		return Object("")
	}
	return o.Object
}

func (o *AssistantObject) GetCreatedAt() int64 {
	if o == nil {
		return 0
	}
	return o.CreatedAt
}

func (o *AssistantObject) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *AssistantObject) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *AssistantObject) GetModel() string {
	if o == nil {
		return ""
	}
	return o.Model
}

func (o *AssistantObject) GetInstructions() *string {
	if o == nil {
		return nil
	}
	return o.Instructions
}

func (o *AssistantObject) GetTools() []Tools {
	if o == nil {
		return []Tools{}
	}
	return o.Tools
}

func (o *AssistantObject) GetToolResources() *ToolResources {
	if o == nil {
		return nil
	}
	return o.ToolResources
}

func (o *AssistantObject) GetMetadata() *Metadata {
	if o == nil {
		return nil
	}
	return o.Metadata
}

func (o *AssistantObject) GetTemperature() *float64 {
	if o == nil {
		return nil
	}
	return o.Temperature
}

func (o *AssistantObject) GetTopP() *float64 {
	if o == nil {
		return nil
	}
	return o.TopP
}

func (o *AssistantObject) GetResponseFormat() *AssistantsAPIResponseFormatOption {
	if o == nil {
		return nil
	}
	return o.ResponseFormat
}
