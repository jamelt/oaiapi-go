// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/jamelt/openai-api/internal/utils"
)

// MessageObjectObject - The object type, which is always `thread.message`.
type MessageObjectObject string

const (
	MessageObjectObjectThreadMessage MessageObjectObject = "thread.message"
)

func (e MessageObjectObject) ToPointer() *MessageObjectObject {
	return &e
}
func (e *MessageObjectObject) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "thread.message":
		*e = MessageObjectObject(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MessageObjectObject: %v", v)
	}
}

// MessageObjectStatus - The status of the message, which can be either `in_progress`, `incomplete`, or `completed`.
type MessageObjectStatus string

const (
	MessageObjectStatusInProgress MessageObjectStatus = "in_progress"
	MessageObjectStatusIncomplete MessageObjectStatus = "incomplete"
	MessageObjectStatusCompleted  MessageObjectStatus = "completed"
)

func (e MessageObjectStatus) ToPointer() *MessageObjectStatus {
	return &e
}
func (e *MessageObjectStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "in_progress":
		fallthrough
	case "incomplete":
		fallthrough
	case "completed":
		*e = MessageObjectStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MessageObjectStatus: %v", v)
	}
}

// MessageObjectReason - The reason the message is incomplete.
type MessageObjectReason string

const (
	MessageObjectReasonContentFilter MessageObjectReason = "content_filter"
	MessageObjectReasonMaxTokens     MessageObjectReason = "max_tokens"
	MessageObjectReasonRunCancelled  MessageObjectReason = "run_cancelled"
	MessageObjectReasonRunExpired    MessageObjectReason = "run_expired"
	MessageObjectReasonRunFailed     MessageObjectReason = "run_failed"
)

func (e MessageObjectReason) ToPointer() *MessageObjectReason {
	return &e
}
func (e *MessageObjectReason) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "content_filter":
		fallthrough
	case "max_tokens":
		fallthrough
	case "run_cancelled":
		fallthrough
	case "run_expired":
		fallthrough
	case "run_failed":
		*e = MessageObjectReason(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MessageObjectReason: %v", v)
	}
}

// MessageObjectIncompleteDetails - On an incomplete message, details about why the message is incomplete.
type MessageObjectIncompleteDetails struct {
	// The reason the message is incomplete.
	Reason MessageObjectReason `json:"reason"`
}

func (o *MessageObjectIncompleteDetails) GetReason() MessageObjectReason {
	if o == nil {
		return MessageObjectReason("")
	}
	return o.Reason
}

// MessageObjectRole - The entity that produced the message. One of `user` or `assistant`.
type MessageObjectRole string

const (
	MessageObjectRoleUser      MessageObjectRole = "user"
	MessageObjectRoleAssistant MessageObjectRole = "assistant"
)

func (e MessageObjectRole) ToPointer() *MessageObjectRole {
	return &e
}
func (e *MessageObjectRole) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "user":
		fallthrough
	case "assistant":
		*e = MessageObjectRole(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MessageObjectRole: %v", v)
	}
}

type MessageObjectContentType string

const (
	MessageObjectContentTypeMessageContentImageFileObject MessageObjectContentType = "MessageContentImageFileObject"
	MessageObjectContentTypeMessageContentImageURLObject  MessageObjectContentType = "MessageContentImageUrlObject"
	MessageObjectContentTypeMessageContentTextObject      MessageObjectContentType = "MessageContentTextObject"
	MessageObjectContentTypeMessageContentRefusalObject   MessageObjectContentType = "MessageContentRefusalObject"
)

type MessageObjectContent struct {
	MessageContentImageFileObject *MessageContentImageFileObject
	MessageContentImageURLObject  *MessageContentImageURLObject
	MessageContentTextObject      *MessageContentTextObject
	MessageContentRefusalObject   *MessageContentRefusalObject

	Type MessageObjectContentType
}

func CreateMessageObjectContentMessageContentImageFileObject(messageContentImageFileObject MessageContentImageFileObject) MessageObjectContent {
	typ := MessageObjectContentTypeMessageContentImageFileObject

	return MessageObjectContent{
		MessageContentImageFileObject: &messageContentImageFileObject,
		Type:                          typ,
	}
}

func CreateMessageObjectContentMessageContentImageURLObject(messageContentImageURLObject MessageContentImageURLObject) MessageObjectContent {
	typ := MessageObjectContentTypeMessageContentImageURLObject

	return MessageObjectContent{
		MessageContentImageURLObject: &messageContentImageURLObject,
		Type:                         typ,
	}
}

func CreateMessageObjectContentMessageContentTextObject(messageContentTextObject MessageContentTextObject) MessageObjectContent {
	typ := MessageObjectContentTypeMessageContentTextObject

	return MessageObjectContent{
		MessageContentTextObject: &messageContentTextObject,
		Type:                     typ,
	}
}

func CreateMessageObjectContentMessageContentRefusalObject(messageContentRefusalObject MessageContentRefusalObject) MessageObjectContent {
	typ := MessageObjectContentTypeMessageContentRefusalObject

	return MessageObjectContent{
		MessageContentRefusalObject: &messageContentRefusalObject,
		Type:                        typ,
	}
}

func (u *MessageObjectContent) UnmarshalJSON(data []byte) error {

	var messageContentImageFileObject MessageContentImageFileObject = MessageContentImageFileObject{}
	if err := utils.UnmarshalJSON(data, &messageContentImageFileObject, "", true, true); err == nil {
		u.MessageContentImageFileObject = &messageContentImageFileObject
		u.Type = MessageObjectContentTypeMessageContentImageFileObject
		return nil
	}

	var messageContentImageURLObject MessageContentImageURLObject = MessageContentImageURLObject{}
	if err := utils.UnmarshalJSON(data, &messageContentImageURLObject, "", true, true); err == nil {
		u.MessageContentImageURLObject = &messageContentImageURLObject
		u.Type = MessageObjectContentTypeMessageContentImageURLObject
		return nil
	}

	var messageContentTextObject MessageContentTextObject = MessageContentTextObject{}
	if err := utils.UnmarshalJSON(data, &messageContentTextObject, "", true, true); err == nil {
		u.MessageContentTextObject = &messageContentTextObject
		u.Type = MessageObjectContentTypeMessageContentTextObject
		return nil
	}

	var messageContentRefusalObject MessageContentRefusalObject = MessageContentRefusalObject{}
	if err := utils.UnmarshalJSON(data, &messageContentRefusalObject, "", true, true); err == nil {
		u.MessageContentRefusalObject = &messageContentRefusalObject
		u.Type = MessageObjectContentTypeMessageContentRefusalObject
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MessageObjectContent", string(data))
}

func (u MessageObjectContent) MarshalJSON() ([]byte, error) {
	if u.MessageContentImageFileObject != nil {
		return utils.MarshalJSON(u.MessageContentImageFileObject, "", true)
	}

	if u.MessageContentImageURLObject != nil {
		return utils.MarshalJSON(u.MessageContentImageURLObject, "", true)
	}

	if u.MessageContentTextObject != nil {
		return utils.MarshalJSON(u.MessageContentTextObject, "", true)
	}

	if u.MessageContentRefusalObject != nil {
		return utils.MarshalJSON(u.MessageContentRefusalObject, "", true)
	}

	return nil, errors.New("could not marshal union type MessageObjectContent: all fields are null")
}

type MessageObjectToolsType string

const (
	MessageObjectToolsTypeAssistantToolsCode               MessageObjectToolsType = "AssistantToolsCode"
	MessageObjectToolsTypeAssistantToolsFileSearchTypeOnly MessageObjectToolsType = "AssistantToolsFileSearchTypeOnly"
)

type MessageObjectTools struct {
	AssistantToolsCode               *AssistantToolsCode
	AssistantToolsFileSearchTypeOnly *AssistantToolsFileSearchTypeOnly

	Type MessageObjectToolsType
}

func CreateMessageObjectToolsAssistantToolsCode(assistantToolsCode AssistantToolsCode) MessageObjectTools {
	typ := MessageObjectToolsTypeAssistantToolsCode

	return MessageObjectTools{
		AssistantToolsCode: &assistantToolsCode,
		Type:               typ,
	}
}

func CreateMessageObjectToolsAssistantToolsFileSearchTypeOnly(assistantToolsFileSearchTypeOnly AssistantToolsFileSearchTypeOnly) MessageObjectTools {
	typ := MessageObjectToolsTypeAssistantToolsFileSearchTypeOnly

	return MessageObjectTools{
		AssistantToolsFileSearchTypeOnly: &assistantToolsFileSearchTypeOnly,
		Type:                             typ,
	}
}

func (u *MessageObjectTools) UnmarshalJSON(data []byte) error {

	var assistantToolsCode AssistantToolsCode = AssistantToolsCode{}
	if err := utils.UnmarshalJSON(data, &assistantToolsCode, "", true, true); err == nil {
		u.AssistantToolsCode = &assistantToolsCode
		u.Type = MessageObjectToolsTypeAssistantToolsCode
		return nil
	}

	var assistantToolsFileSearchTypeOnly AssistantToolsFileSearchTypeOnly = AssistantToolsFileSearchTypeOnly{}
	if err := utils.UnmarshalJSON(data, &assistantToolsFileSearchTypeOnly, "", true, true); err == nil {
		u.AssistantToolsFileSearchTypeOnly = &assistantToolsFileSearchTypeOnly
		u.Type = MessageObjectToolsTypeAssistantToolsFileSearchTypeOnly
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for MessageObjectTools", string(data))
}

func (u MessageObjectTools) MarshalJSON() ([]byte, error) {
	if u.AssistantToolsCode != nil {
		return utils.MarshalJSON(u.AssistantToolsCode, "", true)
	}

	if u.AssistantToolsFileSearchTypeOnly != nil {
		return utils.MarshalJSON(u.AssistantToolsFileSearchTypeOnly, "", true)
	}

	return nil, errors.New("could not marshal union type MessageObjectTools: all fields are null")
}

type MessageObjectAttachments struct {
	// The ID of the file to attach to the message.
	FileID *string `json:"file_id,omitempty"`
	// The tools to add this file to.
	Tools []MessageObjectTools `json:"tools,omitempty"`
}

func (o *MessageObjectAttachments) GetFileID() *string {
	if o == nil {
		return nil
	}
	return o.FileID
}

func (o *MessageObjectAttachments) GetTools() []MessageObjectTools {
	if o == nil {
		return nil
	}
	return o.Tools
}

// MessageObjectMetadata - Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
type MessageObjectMetadata struct {
}

// MessageObject - Represents a message within a [thread](/docs/api-reference/threads).
type MessageObject struct {
	// The identifier, which can be referenced in API endpoints.
	ID string `json:"id"`
	// The object type, which is always `thread.message`.
	Object MessageObjectObject `json:"object"`
	// The Unix timestamp (in seconds) for when the message was created.
	CreatedAt int64 `json:"created_at"`
	// The [thread](/docs/api-reference/threads) ID that this message belongs to.
	ThreadID string `json:"thread_id"`
	// The status of the message, which can be either `in_progress`, `incomplete`, or `completed`.
	Status MessageObjectStatus `json:"status"`
	// On an incomplete message, details about why the message is incomplete.
	IncompleteDetails *MessageObjectIncompleteDetails `json:"incomplete_details"`
	// The Unix timestamp (in seconds) for when the message was completed.
	CompletedAt *int64 `json:"completed_at"`
	// The Unix timestamp (in seconds) for when the message was marked as incomplete.
	IncompleteAt *int64 `json:"incomplete_at"`
	// The entity that produced the message. One of `user` or `assistant`.
	Role MessageObjectRole `json:"role"`
	// The content of the message in array of text and/or images.
	Content []MessageObjectContent `json:"content"`
	// If applicable, the ID of the [assistant](/docs/api-reference/assistants) that authored this message.
	AssistantID *string `json:"assistant_id"`
	// The ID of the [run](/docs/api-reference/runs) associated with the creation of this message. Value is `null` when messages are created manually using the create message or create thread endpoints.
	RunID *string `json:"run_id"`
	// A list of files attached to the message, and the tools they were added to.
	Attachments []MessageObjectAttachments `json:"attachments"`
	// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
	//
	Metadata *MessageObjectMetadata `json:"metadata"`
}

func (o *MessageObject) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *MessageObject) GetObject() MessageObjectObject {
	if o == nil {
		return MessageObjectObject("")
	}
	return o.Object
}

func (o *MessageObject) GetCreatedAt() int64 {
	if o == nil {
		return 0
	}
	return o.CreatedAt
}

func (o *MessageObject) GetThreadID() string {
	if o == nil {
		return ""
	}
	return o.ThreadID
}

func (o *MessageObject) GetStatus() MessageObjectStatus {
	if o == nil {
		return MessageObjectStatus("")
	}
	return o.Status
}

func (o *MessageObject) GetIncompleteDetails() *MessageObjectIncompleteDetails {
	if o == nil {
		return nil
	}
	return o.IncompleteDetails
}

func (o *MessageObject) GetCompletedAt() *int64 {
	if o == nil {
		return nil
	}
	return o.CompletedAt
}

func (o *MessageObject) GetIncompleteAt() *int64 {
	if o == nil {
		return nil
	}
	return o.IncompleteAt
}

func (o *MessageObject) GetRole() MessageObjectRole {
	if o == nil {
		return MessageObjectRole("")
	}
	return o.Role
}

func (o *MessageObject) GetContent() []MessageObjectContent {
	if o == nil {
		return []MessageObjectContent{}
	}
	return o.Content
}

func (o *MessageObject) GetAssistantID() *string {
	if o == nil {
		return nil
	}
	return o.AssistantID
}

func (o *MessageObject) GetRunID() *string {
	if o == nil {
		return nil
	}
	return o.RunID
}

func (o *MessageObject) GetAttachments() []MessageObjectAttachments {
	if o == nil {
		return nil
	}
	return o.Attachments
}

func (o *MessageObject) GetMetadata() *MessageObjectMetadata {
	if o == nil {
		return nil
	}
	return o.Metadata
}
