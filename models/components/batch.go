// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"fmt"
)

// BatchObject - The object type, which is always `batch`.
type BatchObject string

const (
	BatchObjectBatch BatchObject = "batch"
)

func (e BatchObject) ToPointer() *BatchObject {
	return &e
}
func (e *BatchObject) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "batch":
		*e = BatchObject(v)
		return nil
	default:
		return fmt.Errorf("invalid value for BatchObject: %v", v)
	}
}

type BatchData struct {
	// An error code identifying the error type.
	Code *string `json:"code,omitempty"`
	// A human-readable message providing more details about the error.
	Message *string `json:"message,omitempty"`
	// The name of the parameter that caused the error, if applicable.
	Param *string `json:"param,omitempty"`
	// The line number of the input file where the error occurred, if applicable.
	Line *int64 `json:"line,omitempty"`
}

func (o *BatchData) GetCode() *string {
	if o == nil {
		return nil
	}
	return o.Code
}

func (o *BatchData) GetMessage() *string {
	if o == nil {
		return nil
	}
	return o.Message
}

func (o *BatchData) GetParam() *string {
	if o == nil {
		return nil
	}
	return o.Param
}

func (o *BatchData) GetLine() *int64 {
	if o == nil {
		return nil
	}
	return o.Line
}

type Errors struct {
	// The object type, which is always `list`.
	Object *string     `json:"object,omitempty"`
	Data   []BatchData `json:"data,omitempty"`
}

func (o *Errors) GetObject() *string {
	if o == nil {
		return nil
	}
	return o.Object
}

func (o *Errors) GetData() []BatchData {
	if o == nil {
		return nil
	}
	return o.Data
}

// Status - The current status of the batch.
type Status string

const (
	StatusValidating Status = "validating"
	StatusFailed     Status = "failed"
	StatusInProgress Status = "in_progress"
	StatusFinalizing Status = "finalizing"
	StatusCompleted  Status = "completed"
	StatusExpired    Status = "expired"
	StatusCancelling Status = "cancelling"
	StatusCancelled  Status = "cancelled"
)

func (e Status) ToPointer() *Status {
	return &e
}
func (e *Status) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "validating":
		fallthrough
	case "failed":
		fallthrough
	case "in_progress":
		fallthrough
	case "finalizing":
		fallthrough
	case "completed":
		fallthrough
	case "expired":
		fallthrough
	case "cancelling":
		fallthrough
	case "cancelled":
		*e = Status(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Status: %v", v)
	}
}

// RequestCounts - The request counts for different statuses within the batch.
type RequestCounts struct {
	// Total number of requests in the batch.
	Total int64 `json:"total"`
	// Number of requests that have been completed successfully.
	Completed int64 `json:"completed"`
	// Number of requests that have failed.
	Failed int64 `json:"failed"`
}

func (o *RequestCounts) GetTotal() int64 {
	if o == nil {
		return 0
	}
	return o.Total
}

func (o *RequestCounts) GetCompleted() int64 {
	if o == nil {
		return 0
	}
	return o.Completed
}

func (o *RequestCounts) GetFailed() int64 {
	if o == nil {
		return 0
	}
	return o.Failed
}

// BatchMetadata - Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
type BatchMetadata struct {
}

type Batch struct {
	ID string `json:"id"`
	// The object type, which is always `batch`.
	Object BatchObject `json:"object"`
	// The OpenAI API endpoint used by the batch.
	Endpoint string  `json:"endpoint"`
	Errors   *Errors `json:"errors,omitempty"`
	// The ID of the input file for the batch.
	InputFileID string `json:"input_file_id"`
	// The time frame within which the batch should be processed.
	CompletionWindow string `json:"completion_window"`
	// The current status of the batch.
	Status Status `json:"status"`
	// The ID of the file containing the outputs of successfully executed requests.
	OutputFileID *string `json:"output_file_id,omitempty"`
	// The ID of the file containing the outputs of requests with errors.
	ErrorFileID *string `json:"error_file_id,omitempty"`
	// The Unix timestamp (in seconds) for when the batch was created.
	CreatedAt int64 `json:"created_at"`
	// The Unix timestamp (in seconds) for when the batch started processing.
	InProgressAt *int64 `json:"in_progress_at,omitempty"`
	// The Unix timestamp (in seconds) for when the batch will expire.
	ExpiresAt *int64 `json:"expires_at,omitempty"`
	// The Unix timestamp (in seconds) for when the batch started finalizing.
	FinalizingAt *int64 `json:"finalizing_at,omitempty"`
	// The Unix timestamp (in seconds) for when the batch was completed.
	CompletedAt *int64 `json:"completed_at,omitempty"`
	// The Unix timestamp (in seconds) for when the batch failed.
	FailedAt *int64 `json:"failed_at,omitempty"`
	// The Unix timestamp (in seconds) for when the batch expired.
	ExpiredAt *int64 `json:"expired_at,omitempty"`
	// The Unix timestamp (in seconds) for when the batch started cancelling.
	CancellingAt *int64 `json:"cancelling_at,omitempty"`
	// The Unix timestamp (in seconds) for when the batch was cancelled.
	CancelledAt *int64 `json:"cancelled_at,omitempty"`
	// The request counts for different statuses within the batch.
	RequestCounts *RequestCounts `json:"request_counts,omitempty"`
	// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
	//
	Metadata *BatchMetadata `json:"metadata,omitempty"`
}

func (o *Batch) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *Batch) GetObject() BatchObject {
	if o == nil {
		return BatchObject("")
	}
	return o.Object
}

func (o *Batch) GetEndpoint() string {
	if o == nil {
		return ""
	}
	return o.Endpoint
}

func (o *Batch) GetErrors() *Errors {
	if o == nil {
		return nil
	}
	return o.Errors
}

func (o *Batch) GetInputFileID() string {
	if o == nil {
		return ""
	}
	return o.InputFileID
}

func (o *Batch) GetCompletionWindow() string {
	if o == nil {
		return ""
	}
	return o.CompletionWindow
}

func (o *Batch) GetStatus() Status {
	if o == nil {
		return Status("")
	}
	return o.Status
}

func (o *Batch) GetOutputFileID() *string {
	if o == nil {
		return nil
	}
	return o.OutputFileID
}

func (o *Batch) GetErrorFileID() *string {
	if o == nil {
		return nil
	}
	return o.ErrorFileID
}

func (o *Batch) GetCreatedAt() int64 {
	if o == nil {
		return 0
	}
	return o.CreatedAt
}

func (o *Batch) GetInProgressAt() *int64 {
	if o == nil {
		return nil
	}
	return o.InProgressAt
}

func (o *Batch) GetExpiresAt() *int64 {
	if o == nil {
		return nil
	}
	return o.ExpiresAt
}

func (o *Batch) GetFinalizingAt() *int64 {
	if o == nil {
		return nil
	}
	return o.FinalizingAt
}

func (o *Batch) GetCompletedAt() *int64 {
	if o == nil {
		return nil
	}
	return o.CompletedAt
}

func (o *Batch) GetFailedAt() *int64 {
	if o == nil {
		return nil
	}
	return o.FailedAt
}

func (o *Batch) GetExpiredAt() *int64 {
	if o == nil {
		return nil
	}
	return o.ExpiredAt
}

func (o *Batch) GetCancellingAt() *int64 {
	if o == nil {
		return nil
	}
	return o.CancellingAt
}

func (o *Batch) GetCancelledAt() *int64 {
	if o == nil {
		return nil
	}
	return o.CancelledAt
}

func (o *Batch) GetRequestCounts() *RequestCounts {
	if o == nil {
		return nil
	}
	return o.RequestCounts
}

func (o *Batch) GetMetadata() *BatchMetadata {
	if o == nil {
		return nil
	}
	return o.Metadata
}
